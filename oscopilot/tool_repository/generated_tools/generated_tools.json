{
    "add_column": {
        "code": "import mysql.connector  \n\n\n\ndef add_column(table_name, column_name, column_type):\n    \"\"\"\n    Add a new column to an existing table in the database.\n\n    Args:\n    table_name (str): The name of the table to which the column will be added.\n    column_name (str): The name of the new column.\n    column_type (str): The data type of the new column.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u68c0\u67e5\u5217\u662f\u5426\u5b58\u5728\n        describe_query = f\"DESCRIBE {table_name}\"\n        cursor.execute(describe_query)\n        columns = cursor.fetchall()\n        \n        # \u68c0\u67e5\u5217\u540d\u662f\u5426\u5728\u8fd4\u56de\u7684\u7ed3\u679c\u4e2d\n        column_exists = any(column[0] == column_name for column in columns)\n        \n        if not column_exists:\n            # \u6dfb\u52a0\u5217\n            add_column_query = f\"\"\"\n            ALTER TABLE {table_name}\n            ADD COLUMN {column_name} {column_type};\n            \"\"\"\n            \n            # \u6267\u884c\n            cursor.execute(add_column_query)\n            \n            # \u63d0\u4ea4\u4e8b\u52a1\n            conn.commit()\n            \n            print(f\"Column '{column_name}' added to table '{table_name}' successfully.\")\n        else:\n            print(f\"Column '{column_name}' already exists in table '{table_name}'.\")\n    except Exception as e:\n        raise e\n\n\n",
        "description": "Add a new column to an existing table in the database"
    },
    "add_table": {
        "code": "import mysql.connector  \n\ndef add_table(table_name, primary_key_name, primary_key_type):\n    \"\"\"\n    Create a table with the specified name and primary key in the database.\n\n    Args:\n    table_name (str): The name of the table to be created.\n    primary_key_name (str): The name of the primary key column.\n    primary_key_type (str): The data type of the primary key column.\n    \n    Returns:\n    None\n    \"\"\"\n    \n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u521b\u5efa\u8868\n        create_table_query = f\"\"\"\n        CREATE TABLE {table_name} (\n            {primary_key_name} {primary_key_type} AUTO_INCREMENT PRIMARY KEY\n        );\n        \"\"\"\n\n        # \u6267\u884c\n        cursor.execute(create_table_query)\n\n        # \u63d0\u4ea4\u4e8b\u52a1\n        conn.commit()\n\n        print(f\"Table '{table_name}' with primary key '{primary_key_name}' created successfully.\")\n    except Exception as e:\n        raise e\n",
        "description": "Create a table with the specified name and primary key in the database"
    },
    "alter_column": {
        "code": "import mysql.connector  \n\ndef alter_column(table_name, old_column_name, new_column_name, new_column_type):\n    \"\"\"\n    Modify the name and data type of a column in an existing table in the database.\n\n    Args:\n    table_name (str): The name of the table containing the column to be modified.\n    old_column_name (str): The current name of the column to be modified.\n    new_column_name (str): The new name of the column.\n    new_column_type (str): The new data type of the column.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u4fee\u6539\u5217\u540d\u548c\u6570\u636e\u7c7b\u578b\n        modify_column_query = f\"\"\"\n        ALTER TABLE {table_name}\n        CHANGE COLUMN {old_column_name} {new_column_name} {new_column_type};\n        \"\"\"\n\n        # \u6267\u884c\n        cursor.execute(modify_column_query)\n\n        # \u63d0\u4ea4\u4e8b\u52a1\n        conn.commit()\n\n        print(f\"Column '{old_column_name}' in table '{table_name}' modified to '{new_column_name}' with type '{new_column_type}' successfully.\")\n    except Exception as e:\n        raise e\n",
        "description": "Modify the name and data type of a column in an existing table in the database"
    },
    "alter_table_name": {
        "code": "import mysql.connector  \n\n\ndef alter_table_name(old_table_name, new_table_name):\n    \"\"\"\n    Rename a table in the database using try-except block.\n\n    Args:\n    old_table_name (str): The current name of the table to be renamed.\n    new_table_name (str): The new name of the table.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u91cd\u547d\u540d\u8868\n        rename_query = f\"RENAME TABLE {old_table_name} TO {new_table_name};\"\n        \n        # \u6267\u884c\n        cursor.execute(rename_query)\n        \n        # \u63d0\u4ea4\u4e8b\u52a1\n        conn.commit()\n        \n        print(f\"Table '{old_table_name}' renamed to '{new_table_name}' successfully.\")\n    except Exception as e:\n        raise e\n",
        "description": "Rename a table in the database using try-except block"
    },
    "clustering_analysis": {
        "code": "from sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\n\n\ndef clustering_analysis(data, n_clusters):\n    \"\"\"\n    Performs K-Means clustering on the dataset.\n\n    Args:\n        data (pd.DataFrame): Dataset to cluster (numerical features only).\n        n_clusters (int): Number of clusters to create.\n\n    Returns:\n        dict: A dictionary containing the model, cluster labels, and cluster centers.\n    \"\"\"\n    try:\n        model = KMeans(n_clusters=n_clusters, random_state=42)\n        data['cluster'] = model.fit_predict(data)\n        print(f\"Clustering completed. Cluster Centers:\\n{model.cluster_centers_}\")\n\n        # Plot the clusters (for 2D data)\n        if data.shape[1] == 3:  # Assuming 2 features + cluster labels\n            plt.scatter(data.iloc[:, 0], data.iloc[:, 1], c=data['cluster'], cmap='viridis', s=50)\n            plt.scatter(model.cluster_centers_[:, 0], model.cluster_centers_[:, 1], c='red', marker='X', s=200)\n            plt.title('K-Means Clustering')\n            plt.xlabel('Feature 1')\n            plt.ylabel('Feature 2')\n            plt.show()\n\n        return {\n            \"model\": model,\n            \"cluster_labels\": data['cluster'],\n            \"cluster_centers\": model.cluster_centers_\n        }\n    except Exception as e:\n        raise RuntimeError(f\"Error in Clustering analysis: {e}\")\n",
        "description": "Performs K-Means clustering on the dataset"
    },
    "convert_column_type": {
        "code": "import pandas as pd\n\ndef convert_column_type(data, column, dtype):\n    \"\"\"\n    Converts a single column to the specified data type.\n\n    Args:\n        data (pd.DataFrame): The dataset to process.\n        column (str): The column name to convert.\n        dtype (type): The target data type (e.g., int, float, str).\n\n    Returns:\n        pd.DataFrame: The dataset with the converted column type.\n    \"\"\"\n    try:\n        data[column] = data[column].astype(dtype)\n        print(f\"Column '{column}' converted to {dtype}.\")\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in converting column '{column}' to {dtype}: {e}\")",
        "description": "Converts a single column to the specified data type"
    },
    "delete_column": {
        "code": "import mysql.connector  \n\ndef delete_column(table_name, column_name):\n    \"\"\"\n    Delete a column from an existing table in the database if it exists.\n\n    Args:\n    table_name (str): The name of the table containing the column to be deleted.\n    column_name (str): The name of the column to be deleted.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u68c0\u67e5\u5217\u662f\u5426\u5b58\u5728\n        describe_query = f\"DESCRIBE {table_name}\"\n        cursor.execute(describe_query)\n        columns = cursor.fetchall()\n        \n        # \u68c0\u67e5\u5217\u540d\u662f\u5426\u5728\u8fd4\u56de\u7684\u7ed3\u679c\u4e2d\n        column_exists = any(column[0] == column_name for column in columns)\n        \n        if column_exists:\n            # \u5220\u9664\u5217\n            delete_column_query = f\"\"\"\n            ALTER TABLE {table_name}\n            DROP COLUMN {column_name};\n            \"\"\"\n            \n            # \u6267\u884c\n            cursor.execute(delete_column_query)\n            \n            # \u63d0\u4ea4\u4e8b\u52a1\n            conn.commit()\n            \n            print(f\"Column '{column_name}' in table '{table_name}' deleted successfully.\")\n        else:\n            print(f\"Column '{column_name}' does not exist in table '{table_name}'.\")\n    except Exception as e:\n        raise e\n",
        "description": "Delete a column from an existing table in the database if it exists"
    },
    "delete_data": {
        "code": "import mysql.connector\n\ndef delete_data(table_name, where_clause):\n    \"\"\"\n    Deletes data from a specified table in a MySQL database based on a WHERE clause.\n\n    Args:\n    table_name (str): Name of the table from which data will be deleted.\n    where_clause (str): The condition to specify which rows to delete (e.g., \"id = 1\").\n\n    Returns:\n    None\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor()\n\n    sql_query = f'DELETE FROM {table_name} WHERE {where_clause}'\n\n    try:\n        cursor.execute(sql_query)\n        conn.commit() # \u63d0\u4ea4\u66f4\u6539\uff0c\u5c06\u5220\u9664\u64cd\u4f5c\u5e94\u7528\u5230\u6570\u636e\u5e93\u4e2d\n        print(f\"Data deleted successfully from {table_name} where {where_clause}\")\n    except Exception as e:\n        raise e\n    finally:\n        cursor.close()\n        conn.close()\n",
        "description": "Deletes data from a specified table in a MySQL database based on a WHERE clause"
    },
    "delete_table": {
        "code": "import mysql.connector  \n\ntry:\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    if conn.is_connected():\n        print('\u6210\u529f\u8fde\u63a5\u5230MySQL\u6570\u636e\u5e93')\nexcept Exception as e:\n    raise e\n\ncursor = conn.cursor()\n\ndef delete_table(table_name):\n    \"\"\"\n    Delete a table from the database.\n    Args:\n    table_name (str): The name of the table to be deleted.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Exception as e:\n        raise e\n\n    cursor = conn.cursor()\n    try:\n        # \u68c0\u67e5\u8868\u662f\u5426\u5b58\u5728\n        show_tables_query = \"SHOW TABLES;\"\n        cursor.execute(show_tables_query)\n        tables = cursor.fetchall()\n        \n\n        # \u5220\u9664\u8868\u7684SQL\u547d\u4ee4\n        delete_table_query = f\"DROP TABLE {table_name};\"\n        \n        # \u6267\u884c\u5220\u9664\u8868\u7684\u547d\u4ee4\n        cursor.execute(delete_table_query)\n        \n        # \u63d0\u4ea4\u4e8b\u52a1\n        conn.commit()\n        \n        print(f\"Table '{table_name}' deleted successfully.\")\n\n    except Exception as e:\n        raise e",
        "description": "Delete a table from the database"
    },
    "handle_missing_values": {
        "code": "import pandas as pd\n\ndef handle_missing_values(data, method='mean', columns=None):\n    \"\"\"\n    Handles missing values in the dataset by filling or dropping them.\n\n    Args:\n        data (pd.DataFrame): The dataset to process.\n        method (str): The method to handle missing values. Options: 'mean', 'median', 'mode', 'drop'.\n        columns (list): List of columns to process. If None, all columns are processed.\n\n    Returns:\n        pd.DataFrame: The dataset with missing values handled.\n    \"\"\"\n    try:\n        if columns is None:\n            columns = data.columns\n\n        if method == 'mean':\n            data[columns] = data[columns].fillna(data[columns].mean())\n        elif method == 'median':\n            data[columns] = data[columns].fillna(data[columns].median())\n        elif method == 'mode':\n            for col in columns:\n                data[col] = data[col].fillna(data[col].mode()[0])\n        elif method == 'drop':\n            data = data.dropna(subset=columns)\n        else:\n            raise ValueError(\"Invalid method. Choose from 'mean', 'median', 'mode', 'drop'.\")\n\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in handling missing values: {e}\")",
        "description": "Handles missing values in the dataset by filling or dropping them"
    },
    "insert_data": {
        "code": "import mysql.connector\n\ndef insert_data(table_name, data):\n    \"\"\"\n    Inserts data into a specified table in a MySQL database.\n\n    Args:\n    table_name (str): Name of the table where data will be inserted.\n    data (dict): A dictionary where keys are column names and values are the data to insert.\n    data = {\n    'column1': 'value1',\n    'column2': 'value2',\n    'column3': 'value3'\n    }\n\n    Returns:\n    None\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor()\n\n    columns = ', '.join(data.keys())\n    placeholders = ', '.join(['%s' for _ in data])\n    sql_query = f'INSERT INTO {table_name} ({columns}) VALUES ({placeholders})'\n\n    try:\n        cursor.execute(sql_query, tuple(data.values()))\n        conn.commit()\n        print(\"Data inserted successfully\")\n    except mysql.connector.Error as e:\n        raise e\n    finally:\n        cursor.close()\n        conn.close()\n",
        "description": "Inserts data into a specified table in a MySQL database"
    },
    "linear_regression_analysis": {
        "code": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\n\ndef linear_regression_analysis(data, feature_columns, target_column):\n    \"\"\"\n    Performs Linear Regression to predict a continuous variable.\n\n    Args:\n        data (pd.DataFrame): Dataset containing features and target column.\n        feature_columns (list): List of column names used as features.\n        target_column (str): Name of the target column.\n\n    Returns:\n        dict: A dictionary containing the model, predictions, and evaluation metrics.\n    \"\"\"\n    try:\n        X = data[feature_columns]\n        y = data[target_column]\n\n        # Train Linear Regression model\n        model = LinearRegression()\n        model.fit(X, y)\n\n        # Predict on the training set\n        predictions = model.predict(X)\n        mse = mean_squared_error(y, predictions)\n        print(f\"Linear Regression completed. Mean Squared Error (MSE): {mse:.2f}\")\n\n        return {\n            \"model\": model,\n            \"predictions\": predictions,\n            \"mse\": mse,\n            \"coefficients\": model.coef_\n        }\n    except Exception as e:\n        raise RuntimeError(f\"Error in Linear Regression analysis: {e}\")",
        "description": "Performs Linear Regression to predict a continuous variable"
    },
    "normalize_data": {
        "code": "from sklearn.preprocessing import MinMaxScaler\n\ndef normalize_data(data, columns):\n    \"\"\"\n    Normalizes numerical features to a range of [0, 1].\n\n    Args:\n        data (pd.DataFrame): The dataset to process.\n        columns (list): List of column names to normalize.\n\n    Returns:\n        pd.DataFrame: The dataset with normalized columns.\n    \"\"\"\n    try:\n        scaler = MinMaxScaler()\n        data[columns] = scaler.fit_transform(data[columns])\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in data normalization: {e}\")",
        "description": "Normalizes numerical features to a range of [0, 1]"
    },
    "one_hot_encode": {
        "code": "import pandas as pd\n\ndef one_hot_encode(data, columns):\n    \"\"\"\n    Performs one-hot encoding for categorical columns.\n\n    Args:\n        data (pd.DataFrame): The dataset to process.\n        columns (list): List of column names to encode.\n\n    Returns:\n        pd.DataFrame: The dataset with one-hot encoded columns.\n    \"\"\"\n    try:\n        data = pd.get_dummies(data, columns=columns)\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in one-hot encoding: {e}\")",
        "description": "Performs one-hot encoding for categorical columns"
    },
    "search_all_tables": {
        "code": "import mysql.connector\nimport pandas as pd\n\ndef search_all_tables():\n    \"\"\"\n    search all table names, column names, and their data types\n    returns them as a pandas DataFrame.\n\n    Returns:\n    pd.DataFrame: A DataFrame containing table names, column names, and data types.\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor(dictionary=True)\n    \n    # Query to get all table names, column names, and data types\n    sql_query = \"\"\"\n    SELECT \n        TABLE_NAME, \n        COLUMN_NAME, \n        DATA_TYPE\n    FROM \n        INFORMATION_SCHEMA.COLUMNS\n    WHERE \n        TABLE_SCHEMA = 'oscopilot'\n    ORDER BY \n        TABLE_NAME, ORDINAL_POSITION;\n    \"\"\"\n\n    try:\n        cursor.execute(sql_query)\n        result = cursor.fetchall()\n        df = pd.DataFrame(result)\n        print(\"Table and column information fetched successfully\")\n        return df\n    except mysql.connector.Error as e:\n        print(f\"An error occurred: {e}\")\n        return pd.DataFrame()\n    finally:\n        cursor.close()\n        conn.close()\n\n\n\n",
        "description": "search all table names, column names, and their data types"
    },
    "search_table": {
        "code": "import mysql.connector\nimport pandas as pd\n\ndef search_table(table_name, query_columns='*', where_clause=None):\n    \"\"\"\n    Fetches data from a table in a MySQL database and returns it as a pandas DataFrame.\n\n    Args:\n    table_name (str): Name of the table to fetch data from.\n    query_columns (str): Columns to select, defaults to '*'.\n    where_clause (str): Optional WHERE clause to filter data.\n\n    Returns:\n    pd.DataFrame: A DataFrame containing the query result.\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor(dictionary=True)\n    \n    sql_query = f'SELECT {query_columns} FROM {table_name}'\n    if where_clause:\n        sql_query += f' WHERE {where_clause}'\n\n    try:\n        cursor.execute(sql_query)\n        result = cursor.fetchall()\n        df = pd.DataFrame(result)\n        print(\"Data fetched successfully\")\n        return df\n    except mysql.connector.Error as e:\n        print(f\"An error occurred: {e}\")\n        return pd.DataFrame()\n    finally:\n        cursor.close()\n        conn.close()\n\n",
        "description": "Fetches data from a table in a MySQL database and returns it as a pandas DataFrame"
    },
    "select_numeric_range": {
        "code": "import mysql.connector\nimport pandas as pd\n\n\n# \u67e5\u627e\u67d0\u4e2a\u6570\u5b57\u5de6\u53f3\u7684\uff08e.g. \u627e\u51fa20\u5c81\u5de6\u53f3\u7684\u4eba\uff09\ndef select_numeric_range(column, table, condition, min_value, max_value):\n    \"\"\"\n    Performs a numeric range search in a specified table.\n\n    Args:\n    column (str): Column(s) to select.\n    table (str): Table name.\n    condition (str): The column name for the numeric condition (e.g., \"age\" or \"birth_year\").\n    min_value (int or float): The minimum value for the range search.\n    max_value (int or float): The maximum value for the range search.\n\n    Returns:\n    pd.DataFrame: A DataFrame containing the query result.\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor(dictionary=True)\n\n    # \u6784\u5efa\u8303\u56f4\u67e5\u8be2\u7684 WHERE \u5b50\u53e5\n    where_clause = f\"{condition} BETWEEN %s AND %s\"\n    sql_query = f'SELECT {column} FROM {table} WHERE {where_clause}'\n\n    try:\n        cursor.execute(sql_query, (min_value, max_value))\n        result = cursor.fetchall()\n        df = pd.DataFrame(result)\n        print(\"Numeric range search completed successfully\")\n        return df\n    except mysql.connector.Error as e:\n        raise (f\"An error occurred: {e}\")\n        return pd.DataFrame()\n    finally:\n        cursor.close()\n        conn.close()\n",
        "description": "Performs a numeric range search in a specified table"
    },
    "select": {
        "code": "import mysql.connector\n\ndef select(column, table, condition=\"\"):\n    \"\"\"\n    Executes a SQL SELECT query on a specified table with condition(optional) and returns the results as a string.\n\n    Args:\n    - column (str): The column(s) to be retrieved from the table. Can be a single column or a comma-separated list for multiple columns.\n    - table (str): The name of the table from which to retrieve the data.\n    - condition (str, optional): A SQL condition to filter the results. Defaults to an empty string, meaning no condition is applied.\n\n    Returns:\n    - str: The query results, with each row represented as a string and separated by a newline character.\n\n    Raises:\n    - Exception: Propagates any exception encountered during the database operation.\n    \"\"\"\n    try:\n        connection = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n        )\n        \n        with connection.cursor() as cursor:\n            query = f\"SELECT {column} FROM {table}\"\n            if condition:\n                query += f\" WHERE {condition}\"\n            cursor.execute(query)\n            results = cursor.fetchall()\n            result_string = \"\\n\".join(str(row) for row in results)\n            return result_string\n    \n    except Exception as e:\n        raise e\n    \n    finally:\n        if connection.is_connected():\n            connection.close()\n\n",
        "description": "Executes a SQL SELECT query on a specified table with condition(optional) and returns the results as a string"
    },
    "select_vague": {
        "code": "import mysql.connector\nimport pandas as pd\n\ndef select_vague(column, table, condition, vague):\n    \"\"\"\n    Performs a fuzzy search in a specified table.\n\n    Args:\n    column (str): Column to select.\n    table (str): Name of the table to query.\n    condition (str): The condition to filter data (e.g., \"name LIKE %s\").\n    vague (str): The value for the fuzzy search (e.g., \"%John%\").\n\n    Returns:\n    pd.DataFrame: A DataFrame containing the query result.\n    \"\"\"\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor(dictionary=True)\n\n    sql_query = f'SELECT {column} FROM {table} WHERE {condition}'\n\n    try:\n        cursor.execute(sql_query, (vague,))\n        result = cursor.fetchall()\n        df = pd.DataFrame(result)\n        print(\"Fuzzy search completed successfully\")\n        return df\n    except mysql.connector.Error as e:\n        print(f\"An error occurred: {e}\")\n        return pd.DataFrame()\n    finally:\n        cursor.close()\n        conn.close()\n",
        "description": "Performs a fuzzy search in a specified table"
    },
    "show_table_keys": {
        "code": "import mysql.connector  \nfrom aifc import Error\n\ndef show_table_keys(table_name):\n    \"\"\"\n    Show the keys (primary keys, foreign keys, etc.) of a table in the database using try-except block.\n\n    Args:\n    table_name (str): The name of the table to be checked.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Error as e:\n        print(f\":{e}\")\n\n    cursor = conn.cursor()\n    try:\n        # \u68c0\u67e5\u8868\u662f\u5426\u5b58\u5728\n        show_tables_query = \"SHOW TABLES;\"\n        cursor.execute(show_tables_query)\n        tables = cursor.fetchall()\n        \n        # \u68c0\u67e5\u8868\u540d\u662f\u5426\u5728\u8fd4\u56de\u7684\u7ed3\u679c\u4e2d\n        table_exists = any(table[0] == table_name for table in tables)\n        \n        if table_exists:\n            # \u83b7\u53d6\u8868\u7684\u521b\u5efa\u8bed\u53e5\n            show_create_query = f\"SHOW CREATE TABLE {table_name};\"\n            cursor.execute(show_create_query)\n            create_table_statement = cursor.fetchone()\n            \n            # \u63d0\u53d6\u952e\u4fe1\u606f\n            if create_table_statement:\n                print(f\"Keys of table '{table_name}':\")\n                print(create_table_statement[1])\n            else:\n                print(f\"No keys found for table '{table_name}'.\")\n        else:\n            print(f\"Table '{table_name}' does not exist in the database.\")\n    except mysql.connector.Error as e:\n        print(f\"Error showing keys of table '{table_name}': {e}\")\n",
        "description": "Show the keys (primary keys, foreign keys, etc"
    },
    "show_table": {
        "code": "import mysql.connector  \nfrom aifc import Error\n\ndef show_table(table_name):\n    \"\"\"\n    Show the structure of a table in the database using try-except block.\n\n    Args:\n    table_name (str): The name of the table to be described.\n    \n    Returns:\n    None\n    \"\"\"\n    try:\n        conn = mysql.connector.connect(\n            host='154.201.65.130',\n            user='user',\n            password='password',\n            database='oscopilot'\n    )\n    except Error as e:\n        print(f\":{e}\")\n\n    cursor = conn.cursor()\n    try:\n        # \u63cf\u8ff0\u8868\u7684SQL\u547d\u4ee4\n        describe_query = f\"DESCRIBE {table_name};\"\n        \n        # \u6267\u884c\u63cf\u8ff0\u8868\u7684\u547d\u4ee4\n        cursor.execute(describe_query)\n        \n        # \u83b7\u53d6\u5e76\u6253\u5370\u8868\u7ed3\u6784\n        table_structure = cursor.fetchall()\n        print(f\"Structure of table '{table_name}':\")\n        for column in table_structure:\n            print(column)\n    except mysql.connector.Error as e:\n        error_message = str(e)\n        if \"doesn't exist\" in error_message:\n            print(f\"Error: Table '{table_name}' does not exist.\")\n        else:\n            print(f\"Error describing table '{table_name}': {e}\")\n",
        "description": "Show the structure of a table in the database using try-except block"
    },
    "simple_association_analysis": {
        "code": "# \u6240\u9700\u5305\nimport pandas as pd\nfrom mlxtend.frequent_patterns import apriori, association_rules\n\ndef simple_association_analysis(data, min_support=0.1, min_confidence=0.5):\n    \"\"\"\n    Performs a simple association rule mining using Apriori algorithm.\n\n    Args:\n        data (pd.DataFrame): One-hot encoded dataset for analysis.\n        min_support (float): Minimum support threshold for frequent itemsets.\n        min_confidence (float): Minimum confidence threshold for association rules.\n\n    Returns:\n        dict: A dictionary containing frequent itemsets and association rules.\n    \"\"\"\n    try:\n        # Step 1: Find frequent itemsets\n        frequent_itemsets = apriori(data, min_support=min_support, use_colnames=True)\n        print(f\"Frequent Itemsets:\\n{frequent_itemsets}\\n\")\n\n        # Step 2: Generate association rules\n        rules = association_rules(frequent_itemsets, metric=\"confidence\", min_threshold=min_confidence)\n        print(f\"Association Rules:\\n{rules}\\n\")\n\n        return {\n            \"frequent_itemsets\": frequent_itemsets,\n            \"rules\": rules\n        }\n    except Exception as e:\n        raise RuntimeError(f\"Error in simple association analysis: {e}\")",
        "description": "Performs a simple association rule mining using Apriori algorithm"
    },
    "simple_sentiment_analysis": {
        "code": "# \u6240\u9700\u5305\nfrom transformers import pipeline\nimport pandas as pd\n\ndef simple_sentiment_analysis(data, text_column):\n    \"\"\"\n    Performs sentiment analysis on a column of text data from a Pandas DataFrame.\n\n    Args:\n        data (pd.DataFrame): A Pandas DataFrame containing the text data.\n        text_column (str): The name of the column containing text for sentiment analysis.\n\n    Returns:\n        pd.DataFrame: The original DataFrame with two new columns:\n                      'sentiment' (classification label) and 'confidence' (confidence score).\n    \"\"\"\n    try:\n        # Step 1: Ensure the specified column exists\n        if text_column not in data.columns:\n            raise ValueError(f\"Column '{text_column}' not found in the DataFrame.\")\n\n        # Step 2: Extract text data\n        texts = data[text_column].astype(str).tolist()\n\n        # Step 3: Initialize sentiment analysis pipeline\n        sentiment_pipeline = pipeline(\"sentiment-analysis\")\n\n        # Step 4: Perform sentiment analysis\n        results = sentiment_pipeline(texts)\n\n        # Step 5: Append sentiment results to the original DataFrame\n        data['sentiment'] = [result['label'] for result in results]\n        data['confidence'] = [result['score'] for result in results]\n\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in sentiment analysis: {e}\")",
        "description": "Performs sentiment analysis on a column of text data from a Pandas DataFrame"
    },
    "simple_time_series_analysis": {
        "code": "import pandas as pd\nfrom statsmodels.tsa.arima.model import ARIMA\nimport matplotlib.pyplot as plt\n\ndef simple_time_series_analysis(data, date_column, value_column, forecast_steps=5):\n    \"\"\"\n    Performs a simple time series analysis and forecasting using ARIMA.\n\n    Args:\n        data (pd.DataFrame): Dataset containing time series data.\n        date_column (str): Column containing date information.\n        value_column (str): Column containing values to predict.\n        forecast_steps (int): Number of steps to forecast into the future.\n\n    Returns:\n        dict: A dictionary containing the ARIMA model, forecast values, and residuals.\n    \"\"\"\n    try:\n        # Step 1: Convert date column to datetime and set it as the index\n        data[date_column] = pd.to_datetime(data[date_column])\n        data.set_index(date_column, inplace=True)\n\n        # Step 2: Fit ARIMA model\n        model = ARIMA(data[value_column], order=(1, 1, 1))  # (p, d, q)\n        result = model.fit()\n\n        # Step 3: Forecast future values\n        forecast = result.forecast(steps=forecast_steps)\n        print(f\"Forecasted Values:\\n{forecast}\\n\")\n\n        # Step 4: Plot actual values and forecast\n        plt.figure(figsize=(10, 5))\n        plt.plot(data[value_column], label=\"Actual\")\n        plt.plot(range(len(data), len(data) + forecast_steps), forecast, label=\"Forecast\", color='red')\n        plt.legend()\n        plt.title(\"Time Series Forecast\")\n        plt.show()\n\n        return {\n            \"model\": result,\n            \"forecast\": forecast,\n            \"residuals\": result.resid\n        }\n    except Exception as e:\n        raise RuntimeError(f\"Error in simple time series analysis: {e}\")",
        "description": "Performs a simple time series analysis and forecasting using ARIMA"
    },
    "spilt_data": {
        "code": "from sklearn.model_selection import train_test_split\n\ndef split_data(data, target_column, test_size=0.2, random_state=1):\n    \"\"\"\n    Splits the dataset into training and testing sets.\n\n    Args:\n        data (pd.DataFrame): The dataset to split.\n        target_column (str): The target column for supervised learning.\n        test_size (float): Proportion of the dataset to include in the test split.\n        random_state (int): Random seed for reproducibility.\n\n    Returns:\n        tuple: X_train, X_test, y_train, y_test\n    \"\"\"\n    try:\n        X = data.drop(columns=[target_column])\n        y = data[target_column]\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state)\n        return X_train, X_test, y_train, y_test\n    except Exception as e:\n        raise RuntimeError(f\"Error in splitting data: {e}\")",
        "description": "Splits the dataset into training and testing sets"
    },
    "standardize_data": {
        "code": "from sklearn.preprocessing import StandardScaler\n\ndef standardize_data(data, columns):\n    \"\"\"\n    Standardizes numerical features to have zero mean and unit variance.\n\n    Args:\n        data (pd.DataFrame): The dataset to process.\n        columns (list): List of column names to standardize.\n\n    Returns:\n        pd.DataFrame: The dataset with standardized columns.\n    \"\"\"\n    try:\n        scaler = StandardScaler()\n        data[columns] = scaler.fit_transform(data[columns])\n        return data\n    except Exception as e:\n        raise RuntimeError(f\"Error in data standardization: {e}\")",
        "description": "Standardizes numerical features to have zero mean and unit variance"
    },
    "update_data": {
        "code": "import mysql.connector\n\ndef update_data(table_name, data, where_clause):\n    \"\"\"\n    Updates data in a specified table based on a WHERE clause.\n\n    Args:\n    table_name (str): Name of the table to update data.\n    data (dict): A dictionary where keys are column names and values are the new data to update.\n    data = {\n    'column1': 'new_value1',\n    'column2': 'new_value2'\n    }\n    where_clause (str): The condition to specify which rows to update (e.g., \"id = 1\").\n\n    Returns:\n    None\n    \"\"\"\n    # \u68c0\u67e5 where_clause \u662f\u5426\u4e3a\u7a7a\n    if not where_clause:\n        print(\"Error: WHERE clause is required to prevent updating all rows.\")\n        return\n\n    conn = mysql.connector.connect(\n        host='154.201.65.130',\n        user='user',\n        password='password',\n        database='oscopilot'\n    )\n    cursor = conn.cursor()\n\n    set_clause = ', '.join([f\"{column} = %s\" for column in data.keys()])\n    sql_query = f'UPDATE {table_name} SET {set_clause} WHERE {where_clause}'\n\n    try:\n        #\u5982\u679c\u6570\u636e\u5e93\u4e2d\u4e0d\u5b58\u5728\u7b26\u5408\u6761\u4ef6\u7684\u884c\uff0c\u90a3\u4e48 UPDATE \u8bed\u53e5\u4f1a\u6267\u884c\uff0c\u4f46\u4e0d\u4f1a\u66f4\u65b0\u4efb\u4f55\u884c\n        cursor.execute(sql_query, tuple(data.values()))\n        conn.commit()\n        print(f\"Data updated successfully in {table_name} where {where_clause}\")\n    except Exception as e:\n        raise e\n    finally:\n        cursor.close()\n        conn.close()\n",
        "description": "Updates data in a specified table based on a WHERE clause"
    },
    "read_pptx_file": {
        "code": "def read_pptx_file(file_path):\n    \"\"\"\n    Reads a PowerPoint file and extracts the contents of each slide.\n\n    Args:\n        file_path (str): The path to the PowerPoint file.\n\n    Returns:\n        dict: A dictionary where each key is the slide number (starting from 1) and the value is the content of that slide.\n    \"\"\"\n    from pptx import Presentation\n\n    # Initialize a dictionary to store slide contents\n    slide_contents = {}\n\n    # Load the presentation\n    presentation = Presentation(file_path)\n\n    # Iterate over each slide in the presentation\n    for i, slide in enumerate(presentation.slides, start=1):\n        # Extract text from each slide\n        slide_text = []\n        for shape in slide.shapes:\n            if hasattr(shape, \"text\"):\n                slide_text.append(shape.text)\n        \n        # Join all text parts and store in the dictionary\n        slide_contents[i] = \"\\n\".join(slide_text)\n\n    return slide_contents",
        "description": "Reads a PowerPoint file and extracts the contents of each slide"
    },
    "add_slide_to_pptx": {
        "code": "def add_slide_to_pptx(file_path, slide_title, slide_content):\n    \"\"\"\n    Adds a new slide with a title and content layout to a PowerPoint file and saves the modified file.\n\n    Args:\n        file_path (str): The path to the PowerPoint file.\n        slide_title (str): The title of the new slide.\n        slide_content (str): The content of the new slide.\n\n    Returns:\n        str: A message indicating that the slide has been added successfully.\n    \"\"\"\n    from pptx import Presentation\n    from pptx.util import Inches\n\n    # Load the presentation\n    presentation = Presentation(file_path)\n\n    # Define slide layout (0 is the layout index for title and content)\n    slide_layout = presentation.slide_layouts[0]\n\n    # Add a new slide with the specified layout\n    slide = presentation.slides.add_slide(slide_layout)\n\n    # Set the title and content of the slide\n    title = slide.shapes.title\n    content = slide.placeholders[1]\n\n    title.text = slide_title\n    content.text = slide_content\n\n    # Save the modified presentation\n    presentation.save(file_path)\n\n    return \"Slide added successfully.\"",
        "description": "Adds a new slide with a title and content layout to a PowerPoint file and saves the modified file"
    },
    "access_slide": {
        "code": "def access_slide(presentation, slide_number):\n    \"\"\"\n    Accesses a specific slide from a PowerPoint presentation.\n\n    Args:\n        presentation (Presentation): An instance of the Presentation class representing the opened PowerPoint file.\n        slide_number (int): The number of the slide to access (1-based index).\n\n    Returns:\n        Slide: The slide object corresponding to the specified slide number.\n    \"\"\"\n    # Check if the slide number is valid\n    if slide_number < 1 or slide_number > len(presentation.slides):\n        raise ValueError(\"Slide number is out of range.\")\n\n    # Access and return the specified slide\n    return presentation.slides[slide_number - 1]",
        "description": "Accesses a specific slide from a PowerPoint presentation"
    }
}